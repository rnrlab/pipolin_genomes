[
  {
    "objectID": "virulencefinder.html",
    "href": "virulencefinder.html",
    "title": "Virulencefinder",
    "section": "",
    "text": "Los archivos usados son los resultados obtenidos con el script virulencefinder_to_csv.py y un compendio de datos sobre todos los genomas disponibles, del cuál solo nos interesa sus datos taxonómicos y su ID.\n\ndata_vf &lt;- read.csv(\"virulencefinder_output.csv\", stringsAsFactors = F)\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)"
  },
  {
    "objectID": "virulencefinder.html#files",
    "href": "virulencefinder.html#files",
    "title": "Virulencefinder",
    "section": "",
    "text": "Los archivos usados son los resultados obtenidos con el script virulencefinder_to_csv.py y un compendio de datos sobre todos los genomas disponibles, del cuál solo nos interesa sus datos taxonómicos y su ID.\n\ndata_vf &lt;- read.csv(\"virulencefinder_output.csv\", stringsAsFactors = F)\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)"
  },
  {
    "objectID": "virulencefinder.html#obtaining-the-genome_id",
    "href": "virulencefinder.html#obtaining-the-genome_id",
    "title": "Virulencefinder",
    "section": "Obtaining the Genome_ID",
    "text": "Obtaining the Genome_ID\nLos datos del Genome_ID se pueden obtener de los hits de cada genoma. Para extraer sólo cierta parte de una string podemos usar la función str_extract() del paquete stringr. En este caso, para todos los genomas que tiene AL MENOS UNA virulencia, se puede extraer de el Genome_ID con sólo extraer la información de las columnas “stx” y “s.aureus_toxin”.\n\n# THIS IS TO OBTAIN THE GENOME_ID\ndata_vf_new&lt;-as.data.frame(data_vf[-c(1)])\ndata_vf_new$Genome_ID&lt;-NA\ndata_vf_new$Genome_ID&lt;-stringr::str_extract(string = data_vf_new$stx, pattern = \"G_[0-9]+\")\ndata_vf_new$Genome_ID[which(grepl(\"G_\\\\d+\", data_vf_new$Genome_ID)==F)]&lt;-stringr::str_extract(string = data_vf_new$s.aureus_toxin[which(grepl(\"G_\\\\d+\", data_vf_new$s.aureus_toxin)==T)], pattern = \"G_[0-9]+\")\n\nWarning in data_vf_new$Genome_ID[which(grepl(\"G_\\\\d+\", data_vf_new$Genome_ID)\n== : número de items para para sustituir no es un múltiplo de la longitud del\nreemplazo\n\ndata_vf_new &lt;- data_vf_new[,c(9,1,2,3,4,5,6,7,8)]"
  },
  {
    "objectID": "virulencefinder.html#getting-rid-of-no-hit-found",
    "href": "virulencefinder.html#getting-rid-of-no-hit-found",
    "title": "Virulencefinder",
    "section": "Getting rid of “No hit found”",
    "text": "Getting rid of “No hit found”\nNo nos interesa tener información inútil. Así que nos vamos a deshacer de todos los “No hit found” en las 8 columnas de virulencia sustituyéndolos por “NA”. Esto se puede hacer fácil con la función grepl().\n\n# This is to get rid of \"No hit found\"\ndata_vf_binary &lt;- data_vf_new\ndata_vf_binary$virulence_ent[which((grepl(\"No hit found\", data_vf_new$virulence_ent)==T))]&lt;-NA\ndata_vf_binary$listeria[which((grepl(\"No hit found\", data_vf_new$listeria)==T))]&lt;-NA\ndata_vf_binary$s.aureus_hostimm[which((grepl(\"No hit found\", data_vf_new$s.aureus_hostimm)==T))]&lt;-NA\ndata_vf_binary$s.aureus_exoenzyme[which((grepl(\"No hit found\", data_vf_new$s.aureus_exoenzyme)==T))]&lt;-NA\ndata_vf_binary$s.aureus_toxin[which((grepl(\"No hit found\", data_vf_new$s.aureus_toxin)==T))]&lt;-NA\ndata_vf_binary$virulence_ecoli[which((grepl(\"No hit found\", data_vf_new$virulence_ecoli)==T))]&lt;-NA\ndata_vf_binary$stx[which((grepl(\"No hit found\", data_vf_new$stx)==T))]&lt;-NA\ndata_vf_binary$virulence_entfm_entls[which((grepl(\"No hit found\", data_vf_new$virulence_entfm_entls)==T))]&lt;-NA"
  },
  {
    "objectID": "virulencefinder.html#turning-the-results-into-1",
    "href": "virulencefinder.html#turning-the-results-into-1",
    "title": "Virulencefinder",
    "section": "Turning the results into “1”",
    "text": "Turning the results into “1”\nComo he dicho antes, no necesitamos información inútil en nuestros data frames. Igual que hacíamos antes con los “No hit found”, vamos a cambiar todos los hits por “1”.\n\n# THIS IS TO CHANGE RESULTS INTO \"1\"\ndata_vf_binary$virulence_ent[which((grepl(\"G_[0-9]+\", data_vf_binary$virulence_ent)==T))]&lt;-1\ndata_vf_binary$listeria[which((grepl(\"G_[0-9]+\", data_vf_new$listeria)==T))]&lt;-1\ndata_vf_binary$s.aureus_hostimm[which((grepl(\"G_[0-9]+\", data_vf_new$s.aureus_hostimm)==T))]&lt;-1\ndata_vf_binary$s.aureus_exoenzyme[which((grepl(\"G_[0-9]+\", data_vf_new$s.aureus_exoenzyme)==T))]&lt;-1\ndata_vf_binary$s.aureus_toxin[which((grepl(\"G_[0-9]+\", data_vf_new$s.aureus_toxin)==T))]&lt;-1\ndata_vf_binary$virulence_ecoli[which((grepl(\"G_[0-9]+\", data_vf_new$virulence_ecoli)==T))]&lt;-1\ndata_vf_binary$stx[which((grepl(\"G_[0-9]+\", data_vf_new$stx)==T))]&lt;-1\ndata_vf_binary$virulence_entfm_entls[which((grepl(\"G_[0-9]+\", data_vf_new$virulence_entfm_entls)==T))]&lt;-1"
  },
  {
    "objectID": "virulencefinder.html#stacking-virulence-classes-in-one-column",
    "href": "virulencefinder.html#stacking-virulence-classes-in-one-column",
    "title": "Virulencefinder",
    "section": "Stacking Virulence classes in one column",
    "text": "Stacking Virulence classes in one column\nComo nos interesa analizar los datos según su tipo de virulencia, necesitamos que estas pertenezcan todas a una misma variable. Para ello, nos valemos de la función stack() . También podemos deshacernos de todas las columnas que no presentan virulencia mediante la función filter() del paquete dplyr. También podemos agregar la información taxonómica mediante merge() y deshacernos de columnas duplicadas con unique().\n¿Por qué deshacernos de los duplicados si tenemos una variable Count donde podríamos almacenar la información de cuántas columnas son iguales? Sencillo, porque no nos interesa. Nos basta con saber si esa virulencia está (1) o no está (NA) en nuestro genoma.\n\nstacked &lt;- cbind(data_vf_binary$Genome_ID,stack(data_vf_binary[,2:8]))\nnames(stacked) &lt;- c(\"Genome_ID\",\"Count\",\"Virulence\")\nstacked &lt;- stacked %&gt;%filter(!is.na(Count))\nstacked &lt;- unique(stacked)\ndata_vf_merge &lt;- merge(stacked, taxonomy_data, by=\"Genome_ID\")\nvf_merge_filtered &lt;- unique(data_vf_merge)"
  },
  {
    "objectID": "virulencefinder.html#counting-the-occurrence-of-virulences",
    "href": "virulencefinder.html#counting-the-occurrence-of-virulences",
    "title": "Virulencefinder",
    "section": "Counting the occurrence of virulences",
    "text": "Counting the occurrence of virulences\nNos interesa saber la cantidad de genomas que tienen 0, 1, 2, 3, etc. virulencias. Para ello hacemos un df con todos los genomas y hacemos un merge con la información taxonómica. Si el merge lo hacemos según Genome_ID nuestro plot no mostrará la cantidad de genomas que no tienen virulencia. Para mostrar también estos últimos, el merge lo haremos para todo el data frame que contiene la información taxonómica.\n\n# Now to obtain the nº virulences/nº freq plots:\nGenome_vf_name &lt;- as.vector(names(table(vf_merge_filtered$Genome_ID)))\nGenome_vf_count &lt;- as.vector(table(vf_merge_filtered$Genome_ID))\ndf_vf_genome &lt;- data.frame(Genome_vf_name, Genome_vf_count)\ndf_vf_genome &lt;- distinct(df_vf_genome)\nnames(df_vf_genome) &lt;- c(\"Genome_ID\",\"Count\")\n\ndf_temp &lt;- data.frame(vf_merge_filtered$Genome_ID, vf_merge_filtered$Genus_rev)\ndf_temp &lt;- distinct(df_temp)\nnames(df_temp) &lt;- c(\"Genome_ID\",\"Genus_rev\")\n\ndf_vf_genome2 &lt;- merge(df_vf_genome, df_temp, by=\"Genome_ID\")\n\ndf_vf_genome3 &lt;- merge(taxonomy_data, df_vf_genome2, all.x = T)\ndf_vf_genome3$Count[which((grepl(\"[0-9]+\", df_vf_genome3$Count)==F))]&lt;-0"
  },
  {
    "objectID": "virulencefinder.html#plots",
    "href": "virulencefinder.html#plots",
    "title": "Virulencefinder",
    "section": "Plots",
    "text": "Plots\nEl primer gráfico muestra la frecuencia relativa de presencia de cierta viruelncia, coloreada según pertenencia a los géneros más relevantes de bacterias y dividido por clase taxonómica.\n\nggplot(vf_merge_filtered, aes(x=Virulence))+\n  geom_bar(aes(y = after_stat(count)/11430, fill = Genus_rev, alpha=0.1), stat = \"count\", col = \"black\", alpha = 0.6) +\n  facet_grid(.~class, scale=\"free_x\",space=\"free\") + scale_y_continuous(labels=scales::percent) + xlab(\"VIRULENCE\") + ylab(\"Relative Freq\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10, face = \"bold\"))\n\n\n\n\n\n\n\n\nEl segundo muestra qué cantidad de genomas tienen x número de virulencias, sólo para genomas que tengan al menos una.\n\nggplot(df_vf_genome2, aes(Count, fill=Genus_rev)) + geom_bar(stat=\"count\") + xlab(\"Nº VIRULENCES\") + ylab(\"Nº GENOMES\")\n\n\n\n\n\n\n\n\nEl tercero muestra qué cantidad de genomas tienen x número de virulencias, incluyendo aquellos que no presentan ninguna.\n\nggplot(df_vf_genome3, aes(Count, fill=Genus_rev)) + geom_bar(stat=\"count\") + xlab(\"Nº VIRULENCES\") + ylab(\"Nº GENOMES\")"
  },
  {
    "objectID": "virulencefinder.html#session-info",
    "href": "virulencefinder.html#session-info",
    "title": "Virulencefinder",
    "section": "Session Info",
    "text": "Session Info\n\n\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=Spanish_Spain.utf8  LC_CTYPE=Spanish_Spain.utf8   \n[3] LC_MONETARY=Spanish_Spain.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=Spanish_Spain.utf8    \n\ntime zone: Europe/Madrid\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4    \n [5] purrr_1.0.2     readr_2.1.4     tidyr_1.3.0     tibble_3.2.1   \n [9] tidyverse_2.0.0 ggplot2_3.4.4  \n\nloaded via a namespace (and not attached):\n [1] bit_4.0.5         gtable_0.3.4      jsonlite_1.8.8    crayon_1.5.2     \n [5] compiler_4.3.2    tidyselect_1.2.0  parallel_4.3.2    scales_1.3.0     \n [9] yaml_2.3.7        fastmap_1.1.1     R6_2.5.1          labeling_0.4.3   \n[13] generics_0.1.3    knitr_1.45        htmlwidgets_1.6.3 munsell_0.5.0    \n[17] pillar_1.9.0      tzdb_0.4.0        rlang_1.1.2       utf8_1.2.4       \n[21] stringi_1.8.2     xfun_0.41         bit64_4.0.5       timechange_0.2.0 \n[25] cli_3.6.1         withr_2.5.2       magrittr_2.0.3    digest_0.6.33    \n[29] grid_4.3.2        vroom_1.6.4       rstudioapi_0.15.0 hms_1.1.3        \n[33] lifecycle_1.0.4   vctrs_0.6.4       evaluate_0.23     glue_1.6.2       \n[37] farver_2.1.1      fansi_1.0.5       colorspace_2.1-0  rmarkdown_2.25   \n[41] tools_4.3.2       pkgconfig_2.0.3   htmltools_0.5.7"
  },
  {
    "objectID": "integron.html",
    "href": "integron.html",
    "title": "Integron Finder",
    "section": "",
    "text": "Warning: package 'rebus' was built under R version 4.3.3"
  },
  {
    "objectID": "integron.html#files---testing",
    "href": "integron.html#files---testing",
    "title": "Integron Finder",
    "section": "Files - Testing",
    "text": "Files - Testing\nAnalizando resultados de integron_finder con R (prueba con 5 genomas aleatorios) :\n\nObtenemos la lista de los archivos a analizar con list_summary &lt;- list.files(recursive=TRUE, pattern = \"\\\\.summary$\")\n\n\n\nCreamos un df vacío para agregar los resultados summary_df&lt;-data.frame(\"Genome_ID\" = c(NA), \"CALIN\" = c(NA), \"complete\" = c(NA), \"In0\" = c(NA))\n\nLa fila vacía la eliminaremos después de obtener todo los ressultados summary_df &lt;- summary_df %&gt;% na.omit() (Paquete tidyverse)\n\n\n\n\nHacemos un bucle for para leer todos los documentos de la lista:\n\nImportante en read.table añadir skip=1 para omitir la primera línea de texto y header=T para que tod esté en su sitio.\nPara obtener el número de genoma, usamos la función str_extract() (paquete stringr) con el patrón pattern = \"G_[0-9]+\"\nPor cada archivo, obtenemos un df temporal con su G_ID y la suma de cada columna con sum(file$column)\nAñadidimos este df al creado anteriormente como una nueva fila con summary_df[nrow(summary_df) + 1,] &lt;- df_temp\n\n\n\n\nAl acabar el bucle, podemos eliminar el df_temp y el objeto de lectura para mantener el environment organizado\n\n\n\nAbrimos los datos taxonómicos que se encuentran en pipolin_summary_new.tsv y usamos merge() para añadirlos a nuestro df\n\nDe pipolin_summary_new.tsv sólo nos interesant las columnas Genome_ID [3] y Genus_rev [34]\n\n\n\n\nUsaremos stack() para obtener 2 columnas (Count e integron_type) con la que más tarde podremos dividir el gráfico en 3 (CALIN, complete e In0)\n\n\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)\ntaxonomy_data &lt;- taxonomy_data[,c(1,2)]\nsummary_df&lt;-data.frame(\"Genome_ID\" = c(NA), \"CALIN\" = c(NA), \"complete\" = c(NA), \"In0\" = c(NA))\nlist_summary &lt;- list.files(recursive=TRUE, pattern = \"\\\\.summary$\")\n\nfor (k in 1:length(list_summary)){\n  summary &lt;- read.table(list_summary[k], sep=\"\\t\", skip = 1, header = T)\n  G_ID &lt;- str_extract(string = summary$ID_replicon[1], pattern = \"G_[0-9]+\")\n  df &lt;- data.frame(\"Genome_ID\" = c(G_ID), \"CALIN\" = c(sum(summary$CALIN)), \"complete\" = c(sum(summary$complete)), \"In0\" = c(sum(summary$In0)))\n  summary_df[nrow(summary_df) + 1,] &lt;- df\n}\n\nrm(df, summary)\nsummary_df &lt;- summary_df %&gt;% na.omit()\nmerged_df &lt;- merge(summary_df, taxonomy_data, by=\"Genome_ID\")\nstacked &lt;- cbind(summary_df$Genome_ID,stack(summary_df[,2:4]),merged_df$Genus_rev)\nnames(stacked) &lt;- c(\"Genome_ID\",\"Count\",\"Integron_type\",\"Genus_rev\")"
  },
  {
    "objectID": "integron.html#plots---testing",
    "href": "integron.html#plots---testing",
    "title": "Integron Finder",
    "section": "Plots - Testing",
    "text": "Plots - Testing\nHacemos un gráfico de barras con ggplot() que muestre en el eje x la cantidad de integrones y en el eje y en porcentaje de genomas que tienen esa cantidad de integrones:\n\nPara evitar números decimales en el eje x podemos usar scale_x_continuous(breaks=c(0,1,2)\nLos números en el vector breaks serán aquellos que aparezcan el la columna Count del df stacked\n\n\nggplot(stacked, aes(x=Count)) +\n  geom_bar(aes(y = after_stat(count)/(18462/3), fill = Genus_rev, alpha=0.1), stat = \"count\", col = \"black\", alpha = 0.6) +\n  facet_grid(.~Integron_type, scale=\"free\",space=\"free\") + scale_y_continuous(labels=scales::percent) + xlab(\"nº of INTEGRONS\") + ylab(\"Relative Freq\") +\n  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, face = \"bold\")) + scale_x_continuous()"
  },
  {
    "objectID": "integron.html#files---final",
    "href": "integron.html#files---final",
    "title": "Integron Finder",
    "section": "Files - Final",
    "text": "Files - Final\nEstos datos fueron obtenidos con el ordenador del laboratorio, pero usando el mismo código que el que se empleó antes. Para reducir el tamaño del gráfico podemos usar el paquete rebus(). Así juntamos todos los valores mayores que 10 en uno que interpretaremos como “Más de 10 integrones”:\n\nintegron_summary &lt;- read.csv(\"integron_summary.csv\", stringsAsFactors = F)\nnew_summary &lt;- integron_summary\ninterval &lt;- number_range(11,100)\n\nWarning in char_range(d[1, 1], d[nrow(d), 1]): 'lo' and 'hi' are the same\nvalue.  Return 'lo'.\n\nnew_summary$Count[which(grepl(interval,integron_summary$Count)==T)]&lt;-11"
  },
  {
    "objectID": "integron.html#plots---final",
    "href": "integron.html#plots---final",
    "title": "Integron Finder",
    "section": "Plots - Final",
    "text": "Plots - Final\nLos gráficos que se muestran a continuación son 1.- Aquel que muestra toda la información al completo y 2.- Aquel en el que agrupamos todos los resutlados mayores que 10 en uno solo (&gt;10).\n\nggplot(integron_summary, aes(x=Count)) +\n  geom_bar(aes(y = after_stat(count)/(18462/3), fill = Genus_rev, alpha=0.1), stat = \"count\", col = \"black\", alpha = 0.6) +\n  facet_grid(.~Integron_type, scale=\"free\",space=\"free\") + scale_y_continuous(labels=scales::percent) + xlab(\"nº of INTEGRONS\") + ylab(\"Relative Freq\") +\n  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, face = \"bold\")) + scale_x_continuous()\n\n\n\n\n\n\n\nggplot(new_summary, aes(x=Count)) +\n  geom_bar(aes(y = after_stat(count)/(18462/3), fill = Genus_rev, alpha=0.1), stat = \"count\", col = \"black\", alpha = 0.6) +\n  facet_grid(.~Integron_type, scale=\"free\",space=\"free\") + scale_y_continuous(labels=scales::percent) + xlab(\"nº of INTEGRONS\") + ylab(\"Relative Freq\") +\n  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, face = \"bold\")) + scale_x_continuous(breaks = c(0,1,2,3,4,5,6,7,8,9,10,11), labels = c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"&gt;10\"))"
  },
  {
    "objectID": "integron.html#session-info",
    "href": "integron.html#session-info",
    "title": "Integron Finder",
    "section": "Session Info",
    "text": "Session Info\n\n\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=Spanish_Spain.utf8  LC_CTYPE=Spanish_Spain.utf8   \n[3] LC_MONETARY=Spanish_Spain.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=Spanish_Spain.utf8    \n\ntime zone: Europe/Madrid\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] rebus_0.1-3     lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1  \n [5] dplyr_1.1.4     purrr_1.0.2     readr_2.1.4     tidyr_1.3.0    \n [9] tibble_3.2.1    tidyverse_2.0.0 ggplot2_3.4.4  \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4            generics_0.1.3        stringi_1.8.2        \n [4] hms_1.1.3             digest_0.6.33         magrittr_2.0.3       \n [7] evaluate_0.23         grid_4.3.2            timechange_0.2.0     \n[10] fastmap_1.1.1         jsonlite_1.8.8        rebus.datetimes_0.0-2\n[13] fansi_1.0.5           scales_1.3.0          cli_3.6.1            \n[16] rlang_1.1.2           crayon_1.5.2          bit64_4.0.5          \n[19] munsell_0.5.0         withr_2.5.2           yaml_2.3.7           \n[22] tools_4.3.2           parallel_4.3.2        tzdb_0.4.0           \n[25] colorspace_2.1-0      rebus.base_0.0-3      vctrs_0.6.4          \n[28] R6_2.5.1              lifecycle_1.0.4       htmlwidgets_1.6.3    \n[31] bit_4.0.5             vroom_1.6.4           pkgconfig_2.0.3      \n[34] pillar_1.9.0          gtable_0.3.4          glue_1.6.2           \n[37] xfun_0.41             tidyselect_1.2.0      rstudioapi_0.15.0    \n[40] rebus.numbers_0.0-1   knitr_1.45            farver_2.1.1         \n[43] htmltools_0.5.7       labeling_0.4.3        rmarkdown_2.25       \n[46] rebus.unicode_0.0-2   compiler_4.3.2"
  },
  {
    "objectID": "amrfinder.html",
    "href": "amrfinder.html",
    "title": "AMRfinder",
    "section": "",
    "text": "Los archivos usados son los resultados obtenidos con el script amrfinder.py y un compendio de datos sobre todos los genomas disponibles, del cuál solo nos interesa sus datos taxonómicos y su ID.\n\ndata_amrf &lt;- read.csv(\"AMRfinder_output.csv\", sep=\"\\t\", stringsAsFactors = F)\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)"
  },
  {
    "objectID": "amrfinder.html#files",
    "href": "amrfinder.html#files",
    "title": "AMRfinder",
    "section": "",
    "text": "Los archivos usados son los resultados obtenidos con el script amrfinder.py y un compendio de datos sobre todos los genomas disponibles, del cuál solo nos interesa sus datos taxonómicos y su ID.\n\ndata_amrf &lt;- read.csv(\"AMRfinder_output.csv\", sep=\"\\t\", stringsAsFactors = F)\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)"
  },
  {
    "objectID": "amrfinder.html#obtaining-the-genome_id",
    "href": "amrfinder.html#obtaining-the-genome_id",
    "title": "AMRfinder",
    "section": "Obtaining the Genome_ID",
    "text": "Obtaining the Genome_ID\nLos datos del Genome_ID se pueden obtener de los hits de cada genoma. Para extraer sólo cierta parte de una string podemos usar la función str_extract() del paquete stringr.\n\ndata_amrf_new &lt;- data_amrf\ndata_amrf_new$Genome_ID&lt;-NA\ndata_amrf_new$Genome_ID&lt;-stringr::str_extract(string = data_amrf_new$Protein.identifier, pattern = \"G_[0-9]+\")\ndata_amrf_new &lt;- data_amrf_new[,c(19,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)]\ndata_amrf_merge &lt;- merge(data_amrf_new, taxonomy_data, by=\"Genome_ID\")\n\ndata_amrf_filtered &lt;- distinct(data_amrf_merge, Genome_ID, Class)\ndata_amrf_filtered_merged &lt;- merge(data_amrf_filtered, taxonomy_data, all.x = T)\ndata_amrf_filtered_merged &lt;- unique(data_amrf_filtered_merged)\ndata_amrf_filtered_merged &lt;- data_amrf_filtered_merged %&gt;%filter(!is.na(class))"
  },
  {
    "objectID": "amrfinder.html#counting-the-occurrence-of-resistences",
    "href": "amrfinder.html#counting-the-occurrence-of-resistences",
    "title": "AMRfinder",
    "section": "Counting the occurrence of resistences",
    "text": "Counting the occurrence of resistences\nNos interesa saber la cantidad de genomas que tienen 0, 1, 2, 3, etc. resistencias. Para ello hacemos un df con todos los genomas y hacemos un merge con la información taxonómica. Si el merge lo hacemos según Genome_ID nuestro plot no mostrará la cantidad de genomas que no tienen resistencia. Para mostrar también estos últimos, el merge lo haremos según el data frame que contiene la información taxonómica.\n\nGenome_amrf_name &lt;- as.vector(names(table(data_amrf_new$Genome)))\nGenome_amrf_count &lt;- as.vector(table(data_amrf_new$Genome))\ndf_amrf_genome &lt;- data.frame(Genome_amrf_name, Genome_amrf_count)\ndf_amrf_genome &lt;- distinct(df_amrf_genome)\nnames(df_amrf_genome) &lt;- c(\"Genome_ID\",\"Count\")\n\ndf_temp &lt;- data.frame(taxonomy_data$Genome_ID, taxonomy_data$Genus_rev)\ndf_temp &lt;- distinct(df_temp)\nnames(df_temp) &lt;- c(\"Genome_ID\",\"Genus_rev\")\n\ndf_amrf_genome2 &lt;- merge(df_amrf_genome, df_temp, by=\"Genome_ID\")\n\ndf_amrf_genome3 &lt;- merge(taxonomy_data, df_amrf_genome2, all.x = T)\ndf_amrf_genome3$Count[which((grepl(\"[0-9]+\", df_amrf_genome3$Count)==F))]&lt;-0"
  },
  {
    "objectID": "amrfinder.html#plots",
    "href": "amrfinder.html#plots",
    "title": "AMRfinder",
    "section": "Plots",
    "text": "Plots\nEl primer gráfico muestra la frecuencia relativa de presencia de cierta resistencia, coloreada según pertenencia a los géneros más relevantes de bacterias y dividido por clase taxonómica.\n\n#Percentage of Resistence found in relevant Genus\nggplot(data_amrf_filtered_merged, aes(x=Class)) +\n  geom_bar(aes(y = after_stat(count)/11430, fill = Genus_rev, alpha=0.1), stat = \"count\", col = \"black\", alpha = 0.6) +\n  facet_grid(.~class, scale=\"free_x\",space=\"free\") + scale_y_continuous(labels=scales::percent) + xlab(\"RESISTENCE\") + ylab(\"Relative Freq\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, face = \"bold\"))\n\n\n\n\n\n\n\n\nEl segundo muestra qué cantidad de genomas tienen x número de resistencias, sólo para genomas que tengan al menos una.\n\n#nº of Resistences (without Nulls)\nggplot(df_amrf_genome2, aes(Count, fill=Genus_rev)) + geom_bar(stat=\"count\") +\n  xlab(\"Nº OF RESISTENCES\") + ylab(\"OCCURRENCE\")\n\n\n\n\n\n\n\n\nEl tercero muestra qué cantidad de genomas tienen x número de resistencias, incluyendo aquellos que no presentan ninguna.\n\n#nº of Resistences (with Nulls)\nggplot(df_amrf_genome3, aes(Count, fill=Genus_rev)) + geom_bar(stat=\"count\") +\n  xlab(\"Nº OF RESISTENCES\") + ylab(\"OCCURRENCE\")"
  },
  {
    "objectID": "amrfinder.html#session-info",
    "href": "amrfinder.html#session-info",
    "title": "AMRfinder",
    "section": "Session Info",
    "text": "Session Info\n\n\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=Spanish_Spain.utf8  LC_CTYPE=Spanish_Spain.utf8   \n[3] LC_MONETARY=Spanish_Spain.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=Spanish_Spain.utf8    \n\ntime zone: Europe/Madrid\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4    \n [5] purrr_1.0.2     readr_2.1.4     tidyr_1.3.0     tibble_3.2.1   \n [9] tidyverse_2.0.0 ggplot2_3.4.4  \n\nloaded via a namespace (and not attached):\n [1] bit_4.0.5         gtable_0.3.4      jsonlite_1.8.8    crayon_1.5.2     \n [5] compiler_4.3.2    tidyselect_1.2.0  parallel_4.3.2    scales_1.3.0     \n [9] yaml_2.3.7        fastmap_1.1.1     R6_2.5.1          labeling_0.4.3   \n[13] generics_0.1.3    knitr_1.45        htmlwidgets_1.6.3 munsell_0.5.0    \n[17] pillar_1.9.0      tzdb_0.4.0        rlang_1.1.2       utf8_1.2.4       \n[21] stringi_1.8.2     xfun_0.41         bit64_4.0.5       timechange_0.2.0 \n[25] cli_3.6.1         withr_2.5.2       magrittr_2.0.3    digest_0.6.33    \n[29] grid_4.3.2        vroom_1.6.4       rstudioapi_0.15.0 hms_1.1.3        \n[33] lifecycle_1.0.4   vctrs_0.6.4       evaluate_0.23     glue_1.6.2       \n[37] farver_2.1.1      fansi_1.0.5       colorspace_2.1-0  rmarkdown_2.25   \n[41] tools_4.3.2       pkgconfig_2.0.3   htmltools_0.5.7"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Prácticas - Guillermo Cerrillo",
    "section": "",
    "text": "Prácticas Curriculares cursadas en en el Laboratorio de Modestro Redrejo Rodríguez, departamento de Bioquímica, Facultad de Medicina, Universidad Autónoma de Madrid, 2024."
  },
  {
    "objectID": "orit.html",
    "href": "orit.html",
    "title": "oriT",
    "section": "",
    "text": "Los archivos usados son los resultados mediante un script que busca posibles oriTs en pipolinas bacterianas y un compendio de datos sobre todos los genomas disponibles, del cuál solo nos interesa sus datos taxonómicos y su ID.\n\noriT_test &lt;- read_tsv(\"test_oriT.tsv\", col_names = F)\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)"
  },
  {
    "objectID": "orit.html#files",
    "href": "orit.html#files",
    "title": "oriT",
    "section": "",
    "text": "Los archivos usados son los resultados mediante un script que busca posibles oriTs en pipolinas bacterianas y un compendio de datos sobre todos los genomas disponibles, del cuál solo nos interesa sus datos taxonómicos y su ID.\n\noriT_test &lt;- read_tsv(\"test_oriT.tsv\", col_names = F)\npipolin_summary &lt;- read_tsv(\"pipolin_summary_new.tsv\")\ntaxonomy_data &lt;- pipolin_summary[,c(3,34,38:44)]\nrm(pipolin_summary)"
  },
  {
    "objectID": "orit.html#obtaining-the-genome_id",
    "href": "orit.html#obtaining-the-genome_id",
    "title": "oriT",
    "section": "Obtaining the Genome_ID",
    "text": "Obtaining the Genome_ID\nEn este caso, como la información que contiene el Genome_ID siempre va seguida de sólo dos posbiles strings (“_0v0” y ”_1v0”), podemos simplemente sustituir estas terminaciones por un espacio vacío (““) usando gsub().\n\ncolnames(oriT_test) &lt;- c(\"Genome_ID\", \"subject acc.ver\", \"% identity\", \"alignment length\", \"mismatches\", \"gap opens\", \"q. start\", \"q. end\", \"s. start\", \"s. end\", \"evalue\", \"bit score\")\noriT_test$Genome_ID &lt;- gsub(\"_0v0\", \"\", oriT_test$Genome_ID)\noriT_test$Genome_ID &lt;- gsub(\"_1v0\", \"\", oriT_test$Genome_ID)\n\noriT_test_merged &lt;- merge(oriT_test, taxonomy_data, by=\"Genome_ID\")\noriT_test_merged &lt;- unique(oriT_test_merged)"
  },
  {
    "objectID": "orit.html#counting-the-occurrence-of-orits",
    "href": "orit.html#counting-the-occurrence-of-orits",
    "title": "oriT",
    "section": "Counting the occurrence of oriTs",
    "text": "Counting the occurrence of oriTs\nNos interesa saber la cantidad de genomas que tienen 0, 1, 2, 3, etc. oriTs. Para ello hacemos un df con todos los genomas y le agregamos la información taxonómica usando merge().\n\noriT_name &lt;- as.vector(names(table(oriT_test_merged$Genome_ID)))\noriT_count &lt;- as.vector(table(oriT_test_merged$Genome_ID))\noriT_df &lt;- data.frame(oriT_name, oriT_count)\noriT_df &lt;- distinct(oriT_df)\nnames(oriT_df) &lt;- c(\"Genome_ID\",\"Count\")\n\ndf_temp &lt;- data.frame(oriT_test_merged$Genome_ID, oriT_test_merged$Genus_rev)\ndf_temp &lt;- distinct(df_temp)\nnames(df_temp) &lt;- c(\"Genome_ID\",\"Genus_rev\")\n\noriT_df_merged &lt;- merge(oriT_df, df_temp, by=\"Genome_ID\")"
  },
  {
    "objectID": "orit.html#plots",
    "href": "orit.html#plots",
    "title": "oriT",
    "section": "Plots",
    "text": "Plots\nEl gráfico muestra qué cantidad de genomas tienen n número de oriTs, coloreado según pertenencia a un género bacteriano relevantes. En este caso, desde un principio sólo hemos contado los genomas que tengan al menos 1 oriT.\n\n#nº of oriTs\nggplot(oriT_df_merged, aes(Count, fill=Genus_rev)) + geom_bar(stat=\"count\") +\n  xlab(\"Nº of oriTs\") + ylab(\"OCCURRENCE\")"
  },
  {
    "objectID": "orit.html#session-info",
    "href": "orit.html#session-info",
    "title": "oriT",
    "section": "Session Info",
    "text": "Session Info\n\n\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=Spanish_Spain.utf8  LC_CTYPE=Spanish_Spain.utf8   \n[3] LC_MONETARY=Spanish_Spain.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=Spanish_Spain.utf8    \n\ntime zone: Europe/Madrid\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4    \n [5] purrr_1.0.2     readr_2.1.4     tidyr_1.3.0     tibble_3.2.1   \n [9] tidyverse_2.0.0 ggplot2_3.4.4  \n\nloaded via a namespace (and not attached):\n [1] bit_4.0.5         gtable_0.3.4      jsonlite_1.8.8    crayon_1.5.2     \n [5] compiler_4.3.2    tidyselect_1.2.0  parallel_4.3.2    scales_1.3.0     \n [9] yaml_2.3.7        fastmap_1.1.1     R6_2.5.1          labeling_0.4.3   \n[13] generics_0.1.3    knitr_1.45        htmlwidgets_1.6.3 munsell_0.5.0    \n[17] pillar_1.9.0      tzdb_0.4.0        rlang_1.1.2       utf8_1.2.4       \n[21] stringi_1.8.2     xfun_0.41         bit64_4.0.5       timechange_0.2.0 \n[25] cli_3.6.1         withr_2.5.2       magrittr_2.0.3    digest_0.6.33    \n[29] grid_4.3.2        vroom_1.6.4       rstudioapi_0.15.0 hms_1.1.3        \n[33] lifecycle_1.0.4   vctrs_0.6.4       evaluate_0.23     glue_1.6.2       \n[37] farver_2.1.1      fansi_1.0.5       colorspace_2.1-0  rmarkdown_2.25   \n[41] tools_4.3.2       pkgconfig_2.0.3   htmltools_0.5.7"
  }
]